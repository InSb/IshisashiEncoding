# UCS-X 超级扩充方案
在阅读 [UCS-X](https://www.ucsx.org/) 后，我有一个大胆的想法。

下面我将会阐述 UCS-X 的扩充技术细节，以及自己模仿扩充。

## 分段称呼
### UCS-M
指普通的、最大到 U+10FFFF 的情形。

### UCS-G
指最大到 U+7FFFFFFF 的情形。

### UCS-E
指最大到 U+7FFFFFFFFFFFFFFF 的情形。

### UCS-∞
指空间无限的情形。

## 编码方式
以下所述的编码方式承接正常编码方式（包含废案）。

### UTF-8
#### U+80000000~U+FFFFFFFFF
先将 Unicode Code Point 存储为五字节。

这时的结构为：
- 0000aaaa
- aabbbbbb
- ccccccdd
- ddddeeee
- eeffffff

将其代入此结构，形成七字节：
- 11111101
- 10aaaaaa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 68719476736，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=68719476736，也就相当于把二进制的后面 36 位和前面分离了）

将 b₁ 除以 1073741824，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₂ 除以 16777216，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₃ 除以 262144，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₄ 除以 4096，取出商和余数，分别记作 a₅ 和 b₅。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₅ 除以 64，取出商和余数，分别记作 a₆ 和 b₆。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则六个字节分别是：
- a₁+0xFD（即：a₁ 表示是第几次 68719476736 循环，但是 a₁ 在此范围内为 0）
- a₂+0x80（即：a₂ 表示是第几次 1073741824 循环）
- a₃+0x80（即：a₃ 表示是第几次 16777216 循环）
- a₄+0x80（即：a₄ 表示是第几次 262144 循环）
- a₅+0x80（即：a₅ 表示是第几次 4096 循环）
- a₆+0x80（即：a₆ 表示是第几次 64 循环）
- b₆+0x80（即：b₆ 表示 64 循环后的第几个）

由此就得到 U+80000000~U+FFFFFFFFF 的 UTF-8。

### UTF-16
### UTF-32
### UTF-1
#### U+110000 及以上
直接将 UTF-32 转成 UTF-1（即使超过 U+7FFFFFFF）。

### GB 系（GB 18030、UTF-12345）
#### U+110000 及以上
转换成扩充后的 UTF-8，然后在字符的第一字节后面插入字节 0x30。

例如 U+110000 表示成 0xF430908080。
