# UCS-X 超级扩充方案
在阅读 [UCS-X](https://www.ucsx.org/) 后，我有一个大胆的想法。

下面我将会阐述 UCS-X 的扩充技术细节，以及自己模仿扩充。

## 分段称呼
### UCS-M
指普通的、最大到 U+10FFFF 的情形。

### UCS-G
指最大到 U+7FFFFFFF 的情形。

### UCS-E
指最大到 U+7FFFFFFFFFFFFFFF 的情形。

### UCS-∞
指空间无限的情形。

## 编码方式
以下所述的编码方式承接正常编码方式（包含废案）。

### UTF-8
#### U+80000000~U+FFFFFFFFF
先将 Unicode Code Point 存储为五字节。

这时的结构为：
- 0000aaaa
- aabbbbbb
- ccccccdd
- ddddeeee
- eeffffff

将其代入此结构，形成七字节：
- 11111110
- 10aaaaaa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 68719476736，取出商和余数，分别记作 a₁ 和 b₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=68719476736，也就相当于把二进制的后面 36 位和前面分离了）

将 b₁ 除以 1073741824，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₂ 除以 16777216，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₃ 除以 262144，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₄ 除以 4096，取出商和余数，分别记作 a₅ 和 b₅。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₅ 除以 64，取出商和余数，分别记作 a₆ 和 b₆。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则七个字节分别是：
- a₁+0xFE（即：a₁ 表示是第几次 68719476736 循环，但是 a₁ 在此范围内为 0）
- a₂+0x80（即：a₂ 表示是第几次 1073741824 循环）
- a₃+0x80（即：a₃ 表示是第几次 16777216 循环）
- a₄+0x80（即：a₄ 表示是第几次 262144 循环）
- a₅+0x80（即：a₅ 表示是第几次 4096 循环）
- a₆+0x80（即：a₆ 表示是第几次 64 循环）
- b₆+0x80（即：b₆ 表示 64 循环后的第几个）

由此就得到 U+80000000~U+FFFFFFFFF 的 UTF-8。

#### U+1000000000~U+7FFFFFFFFFFFFFFFFF
先将 Unicode Code Point 存储为九字节。

这时的结构为：
- 0aaaaabb
- bbbbcccc
- ccdddddd
- eeeeeeff
- ffffgggg
- gghhhhhh
- iiiiiijj
- jjjjkkkk
- kkllllll

将其代入此结构，形成十三字节：
- 11111111
- 100aaaaa
- 10bbbbbb
- 10cccccc
- 10dddddd
- 10eeeeee
- 10ffffff
- 10gggggg
- 10hhhhhh
- 10iiiiii
- 10jjjjjj
- 10kkkkkk
- 10llllll

拆开来看，就可以这么理解：

先将 Unicode Code Point 记作 U。

将 U 除以 2361183241434822606848，取出商和余数，分别记作 a₁ 和 b₁。（即：(0x9F-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=2361183241434822606848，也就相当于把二进制的后面 71 位和前面分离了）

将 b₁ 除以 73786976294838206464，取出商和余数，分别记作 a₂ 和 b₂。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=73786976294838206464，也就相当于把二进制的后面 66 位和前面分离了）

将 b₂ 除以 1152921504606846976，取出商和余数，分别记作 a₃ 和 b₃。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1152921504606846976，也就相当于把二进制的后面 60 位和前面分离了）

将 b₃ 除以 18014398509481984，取出商和余数，分别记作 a₄ 和 b₄。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=18014398509481984，也就相当于把二进制的后面 54 位和前面分离了）

将 b₄ 除以 281474976710656，取出商和余数，分别记作 a₅ 和 b₅。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=281474976710656，也就相当于把二进制的后面 48 位和前面分离了）

将 b₅ 除以 4398046511104，取出商和余数，分别记作 a₆ 和 b₆。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=4398046511104，也就相当于把二进制的后面 42 位和前面分离了）

将 b₆ 除以 68719476736，取出商和余数，分别记作 a₇ 和 b₇。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=68719476736，也就相当于把二进制的后面 36 位和前面分离了）

将 b₇ 除以 1073741824，取出商和余数，分别记作 a₈ 和 b₈。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=1073741824，也就相当于把二进制的后面 30 位和前面分离了）

将 b₈ 除以 16777216，取出商和余数，分别记作 a₉ 和 b₉。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=16777216，也就相当于把二进制的后面 24 位和前面分离了）

将 b₉ 除以 262144，取出商和余数，分别记作 a₁₀ 和 b₁₀。（即：(0xBF-0x80+1)(0xBF-0x80+1)(0xBF-0x80+1)=262144，也就相当于把二进制的后面 18 位和前面分离了）

将 b₁₀ 除以 4096，取出商和余数，分别记作 a₁₁ 和 b₁₁。（即：(0xBF-0x80+1)(0xBF-0x80+1)=4096，也就相当于把二进制的后面 12 位和前面分离了）

将 b₁₁ 除以 64，取出商和余数，分别记作 a₁₂ 和 b₁₂。（即：0xBF-0x80+1=64，也就相当于把二进制的后面 6 位和前面分离了）

则十三个字节分别是：
- a₁+0xFF（即：a₁ 表示是第几次 2361183241434822606848 循环，但是 a₁ 在此范围内为 0）
- a₂+0x80（即：a₂ 表示是第几次 73786976294838206464 循环）
- a₃+0x80（即：a₃ 表示是第几次 1152921504606846976 循环）
- a₄+0x80（即：a₄ 表示是第几次 18014398509481984 循环）
- a₅+0x80（即：a₅ 表示是第几次 281474976710656 循环）
- a₆+0x80（即：a₆ 表示是第几次 4398046511104 循环）
- a₇+0x80（即：a₇ 表示是第几次 68719476736 循环）
- a₈+0x80（即：a₈ 表示是第几次 1073741824 循环）
- a₉+0x80（即：a₉ 表示是第几次 16777216 循环）
- a₁₀+0x80（即：a₁₀ 表示是第几次 262144 循环）
- a₁₁+0x80（即：a₁₁ 表示是第几次 4096 循环）
- a₁₂+0x80（即：a₁₂ 表示是第几次 64 循环）
- b₁₂+0x80（即：b₁₂ 表示 64 循环后的第几个）

由此就得到 U+1000000000~U+7FFFFFFFFFFFFFFFFF 的 UTF-8。

#### U+800000000000000000 及以上
定义 NUD 为 U+ 后面的十六进制数位数，但不包含前面的 0。

定义 NME=NUD-18。

第一字节为 0xFF。

##### 如果 NME 小于等于 15
那么下一个字节为 0xA0+NME。

##### 如果 NME 大于等于 16
后面会是多个 0xB4 跟随多个 0xA* 字节，0xB4 的数量比 0xA* 的数量少 1。

为什么是 0xB4 呢？因为 B4 谐音 Before（之前）。

那么 0xA* 怎么计算呢？

把 NME 表示成十六进制，再把这串的每一位都加上 0xA0，形成多个字节。

例如当 NME=0x125，那么前面几个字节就是：

0xFFB4B4A1A2A5

执行完上面的步骤后，进入下一个环节。

如果 NUD 不是三的倍数，在 Unicode 码二进制串前面填充 0，直到位数变成 12 的倍数为止。

事实上就相当于在十六进制下将位数填充为 3 的倍数。

此时便可在二进制下把那 Unicode 码点串每六位分割，分割的每个部分前面填充 10，再把处理后的整串填到后面。

下面我们以 U+1000000000000000000000000000000000 为例，进行运算。

容易知道 NUD=34、NME=34-18=16。

所以可以得出前面是 0xFFB4A1A0。

又因为 NUD 不是三的倍数，所以填充 0 变成 0x001000000000000000000000000000000000。

转换成二进制，每六位分割：

000000 000001 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000

补上 10。

10000000 10000001 10000000 10000000 10000000……

所以最终结果是 0xFFB4A1A0808180808080808080808080808080808080808080808080。

### UTF-16
#### U+110000~U+3FFFFFFFFFFFFFFFFFFFFFF
（待补完）

### UTF-32
### UTF-1
#### U+110000 及以上
直接将扩充后的 UTF-32 转成 UTF-1（即使超过 U+7FFFFFFF）。

### GB 系（GB 18030、UTF-12345）
#### U+110000 及以上
转换成扩充后的 UTF-8，然后在字符的第一字节后面插入字节 0x30。

例如 U+110000 表示成 0xF430908080。

### 屁牌编码
#### U+110000 及以上
直接将扩充后的 UTF-16 表示成屁牌形式。
